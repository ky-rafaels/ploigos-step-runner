<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ploigos_step_runner.utils.xml API documentation</title>
<meta name="description" content="Shared utils for dealing with XML." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ploigos_step_runner.utils.xml</code></h1>
</header>
<section id="section-intro">
<p>Shared utils for dealing with XML.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Shared utils for dealing with XML.
&#34;&#34;&#34;

import re
import os.path
from xml.etree import ElementTree

def get_xml_element(xml_file, element_name):
    &#34;&#34;&#34; Gets a given element from a given xml file.

    Raises
    ------
    ValueError
        If the given xml_file does not exist.
        If the given xml_file does not contain an element with the given element_name.

    Returns
    -------
    xml.etree.ElementTree.Element
        The Element matching the given element_name.
    &#34;&#34;&#34;

    xml_element = get_xml_element_if_present(xml_file, element_name)

    # verify information from xml file
    if xml_element is None:
        raise ValueError(&#39;Given xml file (&#39; + \
             xml_file + \
             &#39;) does not have ./&#39; + \
             element_name + \
             &#39; element&#39; \
        )

    return xml_element


def get_xml_element_if_present(xml_file, element_name):
    &#34;&#34;&#34; Gets a given element from a given xml file, if the xml file has that element.
        Otherwise returns None.

    Raises
    ------
    ValueError
        If the given xml_file does not exist.

    Returns
    -------
    xml.etree.ElementTree.Element
        The Element matching the given element_name.
        Or None if the file does not contain an Element with element_name.
    &#34;&#34;&#34;

    # verify runtime config
    if not os.path.exists(xml_file):
        raise ValueError(&#39;Given xml file does not exist: &#39; + xml_file)

    # parse the xml file and figure out the namespace if there is one
    xml_xml = ElementTree.parse(xml_file)
    xml_root = xml_xml.getroot()
    xml_namespace_match = re.match(r&#39;\{.*}&#39;, str(xml_root.tag))
    xml_namespace = &#39;&#39;
    if xml_namespace_match:
        xml_namespace = xml_namespace_match.group(0)

    # extract needed information from the xml file
    if xml_root.tag == element_name:
        xml_element = xml_root
    else:
        xml_element = xml_root.find(&#39;./&#39; + xml_namespace + element_name)

    return xml_element

def get_xml_element_by_path(
    xml_file_path,
    xpath,
    default_namespace=None,
    xml_namespace_dict=None,
    find_all=False
):
    &#34;&#34;&#34;Gets the XML element(s) from a given xml file given an xpath.

    Parameters
    ----------
    xml_file_path : str
        Path of the xml file
    xpath : str
        Xpath of the element you want
    default_namespace : str
        Optional string specifying the default namespace you are using in your xpath selector.
        This is the most common argument that will most likely be used.
        If your XML is namespaced, then even if your elements are in the default namespace,
        you must specify and use this namespace in both your xpath as well as specifying it here.
    xml_namespace_dict : Dict[str, str]
        Optional dictionary if default_namespace is not enough and you have multiple
        namespaces that you need to deal with in your xpath selector.
    find_all : bool
        If False find only the first matching Element.
        If True find all matching elements.

    Returns
    -------
    xml.etree.ElementTree.Element or [xml.etree.ElementTree.Element]
        The Element(s) found given the xpath
    &#34;&#34;&#34;
    # verify runtime config
    if not os.path.exists(xml_file_path):
        raise ValueError(f&#39;Given xml file does not exist: {xml_file_path}&#39;)

    # figure out the xml namespaceing
    xml_file = ElementTree.parse(xml_file_path).getroot()
    namespaces = xml_namespace_dict
    if xml_namespace_dict is None and default_namespace is not None:
        xml_namespace_match = re.findall(r&#39;{(.*?)}&#39;, xml_file.tag)
        xml_namespace = xml_namespace_match[0] if xml_namespace_match else &#39;&#39;
        namespaces = {}
        namespaces[default_namespace] = xml_namespace

    # find the element(s)
    results = None
    if find_all:
        results = xml_file.findall(xpath, namespaces)
    else:
        results = xml_file.find(xpath, namespaces)

    return results

def get_xml_element_text_by_path(
    xml_file_path,
    xpath,
    default_namespace=None,
    xml_namespace_dict=None,
    find_all=False
):
    &#34;&#34;&#34;Gets the text of XML element(s) from a given xml file given an xpath.

    Parameters
    ----------
    xml_file_path : str
        Path of the xml file
    xpath : str
        Xpath of the element you want
    default_namespace : str
        Optional string specifying the default namespace you are using in your xpath selector.
        This is the most common argument that will most likely be used.
        If your XML is namespaced, then even if your elements are in the default namespace,
        you must specify and use this namespace in both your xpath as well as specifying it here.
    xml_namespace_dict : Dict[str, str]
        Optional dictionary if default_namespace is not enough and you have multiple
        namespaces that you need to deal with in your xpath selector.
    find_all : bool
        If False find only the first matching Element.
        If True find all matching elements.

    Returns
    -------
    str or [str]
        The text of the XML elements found given the xpath
    &#34;&#34;&#34;
    xml_elements = get_xml_element_by_path(
        xml_file_path=xml_file_path,
        xpath=xpath,
        default_namespace=default_namespace,
        xml_namespace_dict=xml_namespace_dict,
        find_all=find_all
    )

    result = None
    if find_all:
        result = []
        for xml_element in xml_elements:
            result.append(xml_element.text)
    else:
        result = xml_elements.text

    return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ploigos_step_runner.utils.xml.get_xml_element"><code class="name flex">
<span>def <span class="ident">get_xml_element</span></span>(<span>xml_file, element_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a given element from a given xml file.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given xml_file does not exist.
If the given xml_file does not contain an element with the given element_name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The Element matching the given element_name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xml_element(xml_file, element_name):
    &#34;&#34;&#34; Gets a given element from a given xml file.

    Raises
    ------
    ValueError
        If the given xml_file does not exist.
        If the given xml_file does not contain an element with the given element_name.

    Returns
    -------
    xml.etree.ElementTree.Element
        The Element matching the given element_name.
    &#34;&#34;&#34;

    xml_element = get_xml_element_if_present(xml_file, element_name)

    # verify information from xml file
    if xml_element is None:
        raise ValueError(&#39;Given xml file (&#39; + \
             xml_file + \
             &#39;) does not have ./&#39; + \
             element_name + \
             &#39; element&#39; \
        )

    return xml_element</code></pre>
</details>
</dd>
<dt id="ploigos_step_runner.utils.xml.get_xml_element_by_path"><code class="name flex">
<span>def <span class="ident">get_xml_element_by_path</span></span>(<span>xml_file_path, xpath, default_namespace=None, xml_namespace_dict=None, find_all=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the XML element(s) from a given xml file given an xpath.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xml_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path of the xml file</dd>
<dt><strong><code>xpath</code></strong> :&ensp;<code>str</code></dt>
<dd>Xpath of the element you want</dd>
<dt><strong><code>default_namespace</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional string specifying the default namespace you are using in your xpath selector.
This is the most common argument that will most likely be used.
If your XML is namespaced, then even if your elements are in the default namespace,
you must specify and use this namespace in both your xpath as well as specifying it here.</dd>
<dt><strong><code>xml_namespace_dict</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>Optional dictionary if default_namespace is not enough and you have multiple
namespaces that you need to deal with in your xpath selector.</dd>
<dt><strong><code>find_all</code></strong> :&ensp;<code>bool</code></dt>
<dd>If False find only the first matching Element.
If True find all matching elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code> or <code>[xml.etree.ElementTree.Element]</code></dt>
<dd>The Element(s) found given the xpath</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xml_element_by_path(
    xml_file_path,
    xpath,
    default_namespace=None,
    xml_namespace_dict=None,
    find_all=False
):
    &#34;&#34;&#34;Gets the XML element(s) from a given xml file given an xpath.

    Parameters
    ----------
    xml_file_path : str
        Path of the xml file
    xpath : str
        Xpath of the element you want
    default_namespace : str
        Optional string specifying the default namespace you are using in your xpath selector.
        This is the most common argument that will most likely be used.
        If your XML is namespaced, then even if your elements are in the default namespace,
        you must specify and use this namespace in both your xpath as well as specifying it here.
    xml_namespace_dict : Dict[str, str]
        Optional dictionary if default_namespace is not enough and you have multiple
        namespaces that you need to deal with in your xpath selector.
    find_all : bool
        If False find only the first matching Element.
        If True find all matching elements.

    Returns
    -------
    xml.etree.ElementTree.Element or [xml.etree.ElementTree.Element]
        The Element(s) found given the xpath
    &#34;&#34;&#34;
    # verify runtime config
    if not os.path.exists(xml_file_path):
        raise ValueError(f&#39;Given xml file does not exist: {xml_file_path}&#39;)

    # figure out the xml namespaceing
    xml_file = ElementTree.parse(xml_file_path).getroot()
    namespaces = xml_namespace_dict
    if xml_namespace_dict is None and default_namespace is not None:
        xml_namespace_match = re.findall(r&#39;{(.*?)}&#39;, xml_file.tag)
        xml_namespace = xml_namespace_match[0] if xml_namespace_match else &#39;&#39;
        namespaces = {}
        namespaces[default_namespace] = xml_namespace

    # find the element(s)
    results = None
    if find_all:
        results = xml_file.findall(xpath, namespaces)
    else:
        results = xml_file.find(xpath, namespaces)

    return results</code></pre>
</details>
</dd>
<dt id="ploigos_step_runner.utils.xml.get_xml_element_if_present"><code class="name flex">
<span>def <span class="ident">get_xml_element_if_present</span></span>(<span>xml_file, element_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a given element from a given xml file, if the xml file has that element.
Otherwise returns None.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the given xml_file does not exist.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree.Element</code></dt>
<dd>The Element matching the given element_name.
Or None if the file does not contain an Element with element_name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xml_element_if_present(xml_file, element_name):
    &#34;&#34;&#34; Gets a given element from a given xml file, if the xml file has that element.
        Otherwise returns None.

    Raises
    ------
    ValueError
        If the given xml_file does not exist.

    Returns
    -------
    xml.etree.ElementTree.Element
        The Element matching the given element_name.
        Or None if the file does not contain an Element with element_name.
    &#34;&#34;&#34;

    # verify runtime config
    if not os.path.exists(xml_file):
        raise ValueError(&#39;Given xml file does not exist: &#39; + xml_file)

    # parse the xml file and figure out the namespace if there is one
    xml_xml = ElementTree.parse(xml_file)
    xml_root = xml_xml.getroot()
    xml_namespace_match = re.match(r&#39;\{.*}&#39;, str(xml_root.tag))
    xml_namespace = &#39;&#39;
    if xml_namespace_match:
        xml_namespace = xml_namespace_match.group(0)

    # extract needed information from the xml file
    if xml_root.tag == element_name:
        xml_element = xml_root
    else:
        xml_element = xml_root.find(&#39;./&#39; + xml_namespace + element_name)

    return xml_element</code></pre>
</details>
</dd>
<dt id="ploigos_step_runner.utils.xml.get_xml_element_text_by_path"><code class="name flex">
<span>def <span class="ident">get_xml_element_text_by_path</span></span>(<span>xml_file_path, xpath, default_namespace=None, xml_namespace_dict=None, find_all=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the text of XML element(s) from a given xml file given an xpath.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xml_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path of the xml file</dd>
<dt><strong><code>xpath</code></strong> :&ensp;<code>str</code></dt>
<dd>Xpath of the element you want</dd>
<dt><strong><code>default_namespace</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional string specifying the default namespace you are using in your xpath selector.
This is the most common argument that will most likely be used.
If your XML is namespaced, then even if your elements are in the default namespace,
you must specify and use this namespace in both your xpath as well as specifying it here.</dd>
<dt><strong><code>xml_namespace_dict</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>Optional dictionary if default_namespace is not enough and you have multiple
namespaces that you need to deal with in your xpath selector.</dd>
<dt><strong><code>find_all</code></strong> :&ensp;<code>bool</code></dt>
<dd>If False find only the first matching Element.
If True find all matching elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>[str]</code></dt>
<dd>The text of the XML elements found given the xpath</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xml_element_text_by_path(
    xml_file_path,
    xpath,
    default_namespace=None,
    xml_namespace_dict=None,
    find_all=False
):
    &#34;&#34;&#34;Gets the text of XML element(s) from a given xml file given an xpath.

    Parameters
    ----------
    xml_file_path : str
        Path of the xml file
    xpath : str
        Xpath of the element you want
    default_namespace : str
        Optional string specifying the default namespace you are using in your xpath selector.
        This is the most common argument that will most likely be used.
        If your XML is namespaced, then even if your elements are in the default namespace,
        you must specify and use this namespace in both your xpath as well as specifying it here.
    xml_namespace_dict : Dict[str, str]
        Optional dictionary if default_namespace is not enough and you have multiple
        namespaces that you need to deal with in your xpath selector.
    find_all : bool
        If False find only the first matching Element.
        If True find all matching elements.

    Returns
    -------
    str or [str]
        The text of the XML elements found given the xpath
    &#34;&#34;&#34;
    xml_elements = get_xml_element_by_path(
        xml_file_path=xml_file_path,
        xpath=xpath,
        default_namespace=default_namespace,
        xml_namespace_dict=xml_namespace_dict,
        find_all=find_all
    )

    result = None
    if find_all:
        result = []
        for xml_element in xml_elements:
            result.append(xml_element.text)
    else:
        result = xml_elements.text

    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ploigos_step_runner.utils" href="index.html">ploigos_step_runner.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ploigos_step_runner.utils.xml.get_xml_element" href="#ploigos_step_runner.utils.xml.get_xml_element">get_xml_element</a></code></li>
<li><code><a title="ploigos_step_runner.utils.xml.get_xml_element_by_path" href="#ploigos_step_runner.utils.xml.get_xml_element_by_path">get_xml_element_by_path</a></code></li>
<li><code><a title="ploigos_step_runner.utils.xml.get_xml_element_if_present" href="#ploigos_step_runner.utils.xml.get_xml_element_if_present">get_xml_element_if_present</a></code></li>
<li><code><a title="ploigos_step_runner.utils.xml.get_xml_element_text_by_path" href="#ploigos_step_runner.utils.xml.get_xml_element_text_by_path">get_xml_element_text_by_path</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>