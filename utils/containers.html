<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ploigos_step_runner.utils.containers API documentation</title>
<meta name="description" content="Shared utils for dealing with containers." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ploigos_step_runner.utils.containers</code></h1>
</header>
<section id="section-intro">
<p>Shared utils for dealing with containers.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Shared utils for dealing with containers.
&#34;&#34;&#34;

import json
import sys
from io import StringIO

import sh
from ploigos_step_runner.config.config_value import ConfigValue
from ploigos_step_runner.utils.io import \
    create_sh_redirect_to_multiple_streams_fn_callback


def container_registries_login(  #pylint: disable=too-many-branches
    registries,
    containers_config_auth_file=None,
    containers_config_tls_verify=True,
    container_command_short_name=None
):
    &#34;&#34;&#34;Logs into one or more container registries.

    Requires one of the following to be installed to do the authentication:
    * buidlah
    * podman
    * skopeo

    Notes
    -----
    registries example 1 (dict of dicts where child dict keys are registry uri):

        {
            &#39;registry.redhat.io&#39;: {
                &#39;username&#39;: &#39;hello@world.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            },
            &#39;registry.internal.example.xyz&#39;: {
                &#39;username&#39;: &#39;hello@example.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            }
        }

    registries example 2 (dict of dicts where uri is key in child dicts):

        {
            &#39;redhat&#39;: {
                &#39;uri&#39;: registry.redhat.io
                &#39;username&#39;: &#39;hello@world.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            },
            &#39;internal&#39;: {
                &#39;uri&#39;: &#39;registry.internal.example.xyz&#39;
                &#39;username&#39;: &#39;hello@example.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            }
        }

    registries example 3 (list of dicts where uri is key in child dicts):

        [
            {
                &#39;uri&#39;: registry.redhat.io
                &#39;username&#39;: &#39;hello@world.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            },
            {
                &#39;uri&#39;: &#39;registry.internal.example.xyz&#39;
                &#39;username&#39;: &#39;hello@example.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            }
        ]

    Parameters
    ----------
    registries : dict or list or None
        Dict of dicts of registry configurations or a list of dicts of registry configurations.
        See Notes section for details.
        If none, does nothing.
    containers_config_auth_file : str, optional
        Path of the authentication file.
        If not specified default of the underlying authentication system will be used.
    container_command_short_name : str, optional
        Short name for the command to log in with.
        If not provided will pick the first command found in order (buildah, podman, skopeo).

    See Also
    --------
    container_registry_login : Performs the login for a single container registry
    sh.buildah : https://www.mankier.com/1/buildah-login
    sh.podman : https://www.mankier.com/1/podman-login
    sh.skopeo : https://www.mankier.com/1/skopeo-login
    &#34;&#34;&#34;

    if registries is None:
        return

    assert isinstance(registries, (dict, list))

    if isinstance(registries, dict):
        for registry_key, registry_conf in registries.items():
            if isinstance(registry_conf, ConfigValue):
                registry_conf = registry_conf.value

            assert &#39;username&#39; in registry_conf, \
                f&#34;Configuration for container registry ({registry_key}) &#34; \
                f&#34;must specify a &#39;username&#39;: {registry_conf}&#34;
            assert &#39;password&#39; in registry_conf, \
                f&#34;Configuration for container registry ({registry_key}) &#34; \
                f&#34;must specify a &#39;password&#39;: {registry_conf}&#34;

            # if uri is key in the dict then use that for the registry uri
            # else use the dict key for the registry conf as the registry uri
            if &#39;uri&#39; in registry_conf:
                registry_uri = registry_conf[&#39;uri&#39;]
            else:
                registry_uri = registry_key

            if containers_config_tls_verify:
                if &#39;tls-verify&#39; in registry_conf:
                    registry_tls_verify = registry_conf[&#39;tls-verify&#39;]
                else:
                    registry_tls_verify = True
            else:
                registry_tls_verify = False

            container_registry_login(
                container_registry_uri=registry_uri,
                container_registry_username=registry_conf[&#39;username&#39;],
                container_registry_password=registry_conf[&#39;password&#39;],
                container_registry_tls_verify=registry_tls_verify,
                containers_config_auth_file=containers_config_auth_file,
                container_command_short_name=container_command_short_name
            )
    elif isinstance(registries, list):
        for registry_conf in registries:
            if isinstance(registry_conf, ConfigValue):
                registry_conf = registry_conf.value

            assert &#39;uri&#39; in registry_conf, \
                f&#34;Configuration for container registry &#34; \
                f&#34;must specify a &#39;uri&#39;: {registry_conf}&#34;
            assert &#39;username&#39; in registry_conf, \
                f&#34;Configuration for container registry &#34; \
                f&#34;must specify a &#39;username&#39;: {registry_conf}&#34;
            assert &#39;password&#39; in registry_conf, \
                f&#34;Configuration for container registry &#34; \
                f&#34;must specify a &#39;password&#39;: {registry_conf}&#34;

            if containers_config_tls_verify:
                if &#39;tls-verify&#39; in registry_conf:
                    registry_tls_verify = registry_conf[&#39;tls-verify&#39;]
                else:
                    registry_tls_verify = True
            else:
                registry_tls_verify = False

            container_registry_login(
                container_registry_uri=registry_conf[&#39;uri&#39;],
                container_registry_username=registry_conf[&#39;username&#39;],
                container_registry_password=registry_conf[&#39;password&#39;],
                container_registry_tls_verify=registry_tls_verify,
                containers_config_auth_file=containers_config_auth_file,
                container_command_short_name=container_command_short_name
            )

def container_registry_login( #pylint: disable=too-many-arguments,too-many-branches
    container_registry_uri,
    container_registry_username,
    container_registry_password,
    container_registry_tls_verify=True,
    containers_config_auth_file=None,
    container_command_short_name=None
):
    &#34;&#34;&#34;Performs the login for a single container registry.

    Requires one of the following to be installed to do the authentication:
    * buidlah
    * podman
    * skopeo

    Parameters
    ----------
    container_registry_uri : str or ConfigValue
        URI to the container registry to log into.
    container_registry_username : str or ConfigValue
        Username to log into the container registry with.
    container_registry_password : str or ConfigValue
        Password to log into the container registry with.
    container_registry_tls_verify : bool or str or ConfigValue
        True to verify container registry certificates as part of authenticating.
        False to ignore certificate chain.
        NOTE: no matter what SSL is used to authenticate with container registry
    containers_config_auth_file : str or ConfigValue, optional
        Path of the authentication file.
        If not specified default of the underlying authentication system will be used.
    container_command_short_name : str, optional
        Short name for the command to log in with.
        If not provided will pick the first command found in order (buildah, podman, skopeo).

    Raises
    ------
    RuntimeError
        When can not find tool to login to container registry with.
        When error loging into container registry.

    See Also
    --------
    container_registries_login : authenticate with multiple container registries
    sh.buildah : https://www.mankier.com/1/buildah-login
    sh.podman : https://www.mankier.com/1/podman-login
    sh.skopeo : https://www.mankier.com/1/skopeo-login
    &#34;&#34;&#34;

    assert container_registry_uri
    assert container_registry_username
    assert container_registry_password

    if isinstance(container_registry_uri, ConfigValue):
        container_registry_uri = container_registry_uri.value
    if isinstance(container_registry_username, ConfigValue):
        container_registry_username = container_registry_username.value
    if isinstance(container_registry_password, ConfigValue):
        container_registry_password = container_registry_password.value
    if isinstance(container_registry_tls_verify, ConfigValue):
        container_registry_tls_verify = container_registry_tls_verify.value
    if isinstance(containers_config_auth_file, ConfigValue):
        containers_config_auth_file = containers_config_auth_file.value

    # can use any of these tools to authenticate, look for them all and use first available
    #
    # NOTE: this all works because these three commands take the exact same parameters for login
    # if implementing some new command, like docker, you will need to deal with the differences
    buildah_path = sh.which(&#39;buildah&#39;)
    podman_path = sh.which(&#39;podman&#39;)
    skopeo_path = sh.which(&#39;skopeo&#39;)
    if container_command_short_name:
        given_command_path = sh.which(container_command_short_name)
        if given_command_path:
            container_command = sh.Command(container_command_short_name).bake()
        else:
            raise RuntimeError(
                f&#34;When attempting to login to container registry ({container_registry_uri}) &#34;
                f&#34;could not find the given expected tool ({container_command_short_name}) &#34;
                &#34;to login with.&#34;
            )
    elif buildah_path is not None:
        container_command = sh.buildah.bake() #pylint: disable=no-member
    elif podman_path is not None:
        container_command = sh.podman.bake() #pylint: disable=no-member
    elif skopeo_path is not None:
        container_command = sh.skopeo.bake() #pylint: disable=no-member
    else:
        raise RuntimeError(
            f&#34;When attempting to login to container registry ({container_registry_uri}) &#34;
            &#34;could not find one of the expected tools (buildah, podman, skopeo) to login with.&#34;
        )

    login_command_named_flags = {
        &#39;password_stdin&#39;: True,
        &#39;username&#39;: container_registry_username,
        &#39;tls_verify&#39;: str(container_registry_tls_verify).lower()
    }
    if containers_config_auth_file:
        login_command_named_flags[&#39;authfile&#39;] = containers_config_auth_file

    try:
        # NOTE: need to bake in the flags prior to the registry due to nonesense with
        #       required ordering by the login command and how sh handles
        #       escaping and ordering parameters
        print(f&#34;Login ({container_command}) to container image registry ({container_registry_uri})&#34;)
        login_comnmand = container_command.login.bake(**login_command_named_flags)
        login_comnmand(
            container_registry_uri,
            _in=container_registry_password,
            _out=sys.stdout,
            _err=sys.stderr,
            _tee=&#39;err&#39;
        )
    except sh.ErrorReturnCode as error:
        raise RuntimeError(
            f&#34;Failed to login to container registry ({container_registry_uri}) &#34;
            f&#34;with username ({container_registry_username}): {error}&#34;
        ) from error

def create_container_from_image(
    image_address,
    repository_type=&#39;container-storage:&#39;
):
    &#34;&#34;&#34;Import a container image using buildah form a TAR file.

    Parameters
    ----------
    image_address : str
        Image tag to create a container from.
        ex:
        * localhost/my-app:latest
        * quay.io/my-org/my-app:latest
        * docker-archive:/local/path/to/my-app-container-image.tar
    container_name : str
        name for the working container.
    repository_type : str
        The type of repository to mount the given image tag from.
        See https://github.com/containers/skopeo for details on different repository types.

    Returns
    -------
    str
        Name of the imported container.

    Raises
    ------
    RuntimeError
        If error importing image.
    &#34;&#34;&#34;
    container_name = None
    try:
        buildah_from_out_buff = StringIO()
        buildah_from_out_callback = create_sh_redirect_to_multiple_streams_fn_callback([
            sys.stdout,
            buildah_from_out_buff
        ])
        sh.buildah(  # pylint: disable=no-member
            &#39;from&#39;,
            f&#34;{repository_type}{image_address}&#34;,
            _out=buildah_from_out_callback,
            _err=sys.stderr,
            _tee=&#39;err&#39;
        )
        container_name = buildah_from_out_buff.getvalue().rstrip()
    except sh.ErrorReturnCode as error:
        raise RuntimeError(
            f&#39;Error creating container from image ({image_address}): {error}&#39;
        ) from error

    return container_name


def mount_container(buildah_unshare_command, container_id):
    &#34;&#34;&#34;Use buildah to mount a container.

    Parameters
    ----------
    buildah_unshare_command : sh.buildah.unshare.bake()
        A baked sh.buildah.unshare command to use to run this command in the context off
        so that this can be done &#34;rootless&#34;.
    container_id : str
        ID of the container to mount.

    Returns
    -------
    str
        Absolute path to the mounted container.

    Raises
    ------
    RuntimeError
        If error mounting the container.
    &#34;&#34;&#34;
    mount_path = None
    try:
        buildah_mount_out_buff = StringIO()
        buildah_mount_out_callback = create_sh_redirect_to_multiple_streams_fn_callback([
            sys.stdout,
            buildah_mount_out_buff
        ])
        buildah_mount_command = buildah_unshare_command.bake(&#34;buildah&#34;, &#34;mount&#34;)
        buildah_mount_command(
            container_id,
            _out=buildah_mount_out_callback,
            _err=sys.stderr,
            _tee=&#39;err&#39;
        )
        mount_path = buildah_mount_out_buff.getvalue().rstrip()
    except sh.ErrorReturnCode as error:
        raise RuntimeError(
            f&#39;Error mounting container ({container_id}): {error}&#39;
        ) from error

    return mount_path

def determine_container_image_address_info(
    contaimer_image_registry,
    container_image_tag,
    organization,
    application_name,
    service_name
):
    &#34;&#34;&#34;Determines the full and short build tags for a new container image.

    Parameters
    ----------
    container_image_tag : str
        A given image version. If none given, latest will be used.
    organization : str
        Organization the container image belongs to.
    application_name : str
        Application the container image belongs to.
    service_name : str
        Service the container image implements.

    Returns
    -------
    str, str, str, str, str
        First result is the full build tag, including registry URI.
        Second result is the short build tag, as in no registry URI.
        Third result is the image registry uri.
        Forth result is the image repository name.
        Fifth result is the used image version.

    &#34;&#34;&#34;
    if container_image_tag is None:
        container_image_tag = &#39;latest&#39;
        print(&#39;No image tag version found in metadata. Using latest&#39;)

    container_image_repository = f&#34;{organization}/{application_name}&#34;
    if service_name:
        container_image_repository += f&#34;/{service_name}&#34;

    container_image_build_short_address = f&#34;{container_image_repository}:{container_image_tag}&#34;
    container_image_build_address = \
        f&#34;{contaimer_image_registry}/{container_image_build_short_address}&#34;

    return container_image_build_address, container_image_build_short_address,\
        contaimer_image_registry, container_image_repository, container_image_tag

def inspect_container_image(
    container_image_address,
    containers_config_auth_file=None
):
    &#34;&#34;&#34;Inspects a given container image for all its details. Useful for getting image labels
    and such.

    Parameters
    ----------
    container_image_address : str
        URI to the container image to inspect
    containers_config_auth_file : str
        Path to container image registries authentication file.

    Raises
    ------
    RuntimeError
        If issue running `buildah inspect`

    Returns
    -------
    dict
        Container image details from `buildah inspect`
    &#34;&#34;&#34;
    buildah_inspect = None

    # determine auth flags
    if containers_config_auth_file:
        buildah_authfile_flags = [&#39;--authfile&#39;, containers_config_auth_file]
    else:
        buildah_authfile_flags = []

    # pull container image (can&#39;t inspect remote image)
    try:
        sh.buildah.pull( # pylint: disable=no-member
            *buildah_authfile_flags,
            container_image_address
        )
    except sh.ErrorReturnCode as error:  # pylint: disable=undefined-variable
        raise RuntimeError(
            f&#34;Error pulling container image ({container_image_address}) for inspection: {error}&#34;
        ) from error

    # get container image information
    try:

        buildah_inspect_out_buff = StringIO()
        sh.buildah.inspect( # pylint: disable=no-member
            container_image_address,
            _out=buildah_inspect_out_buff
        )
        buildah_inspect_out = buildah_inspect_out_buff.getvalue().rstrip()
        buildah_inspect = json.loads(buildah_inspect_out)
    except sh.ErrorReturnCode as error:  # pylint: disable=undefined-variable
        raise RuntimeError(
            f&#34;Error inspecting container image ({container_image_address}): {error}&#34;
        ) from error

    return buildah_inspect

def get_container_image_digest(
    container_image_address,
    containers_config_auth_file=None
):
    &#34;&#34;&#34;Get the container image digest for a given container image.

    Will pull the given container image if needed.

    Parameters
    ----------
    container_image_address : str
        URI to the container image to get the container image digest for.
    containers_config_auth_file : str
        Path to container image registries authentication file.

    Raises
    ------
    RuntimeError
        If error inspecting container image to get digest.
        If error finding digest on container image inspection results.

    Returns
    -------
    str
        Container image digest for given container image.
    &#34;&#34;&#34;
    try:
        container_image_details = inspect_container_image(
            container_image_address=container_image_address,
            containers_config_auth_file=containers_config_auth_file
        )

        return container_image_details[&#39;FromImageDigest&#39;]
    except RuntimeError as error:
        raise RuntimeError(
            f&#34;Error getting container image ({container_image_address}) image digest: {error}&#34;
        ) from error
    except KeyError as error:
        raise RuntimeError(
            f&#34;Error finding container image ({container_image_address}) image digest from&#34; \
            f&#34; container image inspection.&#34;
        ) from error

def add_container_build_step_result_artifacts(
    step_result,
    contaimer_image_registry,
    container_image_repository,
    container_image_tag,
    container_image_digest,
    container_image_build_address,
    container_image_build_short_address
): # pylint: disable=too-many-arguments
    &#34;&#34;&#34;Helper function to consistently add step results when building a container image.

    NOTE: long term probably should move this into some mixin class that all container build
    StepImplementers also inherit from, but thats another pattern don&#39;t want to introduce right now.

    Parameters
    ----------
    step_result : StepResult
        Step result to add the container build artifacts to.
    contaimer_image_registry : str
        Container image registry the image was built into.
    container_image_repository : str
        Container image repository the image was built into.
    container_image_tag : str
        Container image tag the built image was tagged with.
    container_image_digest : str
        Container image digest of built image.
    container_image_build_address : str
        Container image full address (with registry) the image was built into and can
        be referenced by to push somewhere else.
    container_image_build_short_address : str
        Container image short address (without registry) the image was built into and can
        be referenced by to push somewhere else, assuming the registry is on the local container
        search path.

    Results
    -------
    step_result : StepResult
        The given StepResult which was modified in place.
        Returned for convenience / and clarity.
    &#34;&#34;&#34;
    if contaimer_image_registry:
        step_result.add_artifact(
            name=&#39;container-image-registry&#39;,
            value=contaimer_image_registry,
            description=&#39;Container image registry of the built container image address.&#39;
        )
    if container_image_repository:
        step_result.add_artifact(
            name=&#39;container-image-repository&#39;,
            value=container_image_repository,
            description=&#39;Container image repository of the built container image address.&#39;
        )
    if container_image_tag:
        step_result.add_artifact(
            name=&#39;container-image-tag&#39;,
            value=container_image_tag,
            description=&#39;Container image tag of the built container image address.&#39;
        )
    if container_image_digest:
        step_result.add_artifact(
            name=&#39;container-image-build-digest&#39;,
            value=container_image_digest,
            description=&#39;Container image digest of the built container image address.&#39;
        )
    if container_image_build_address:
        step_result.add_artifact(
            name=&#39;container-image-build-address&#39;,
            value=container_image_build_address,
            description=&#39;Container image address of the built container image.&#39;
        )
    if container_image_build_short_address:
        step_result.add_artifact(
            name=&#39;container-image-build-short-address&#39;,
            value=container_image_build_short_address,
            description=&#39;Container image short address (no registry) of the built container image.&#39;
        )

    return step_result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ploigos_step_runner.utils.containers.add_container_build_step_result_artifacts"><code class="name flex">
<span>def <span class="ident">add_container_build_step_result_artifacts</span></span>(<span>step_result, contaimer_image_registry, container_image_repository, container_image_tag, container_image_digest, container_image_build_address, container_image_build_short_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to consistently add step results when building a container image.</p>
<p>NOTE: long term probably should move this into some mixin class that all container build
StepImplementers also inherit from, but thats another pattern don't want to introduce right now.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>step_result</code></strong> :&ensp;<code>StepResult</code></dt>
<dd>Step result to add the container build artifacts to.</dd>
<dt><strong><code>contaimer_image_registry</code></strong> :&ensp;<code>str</code></dt>
<dd>Container image registry the image was built into.</dd>
<dt><strong><code>container_image_repository</code></strong> :&ensp;<code>str</code></dt>
<dd>Container image repository the image was built into.</dd>
<dt><strong><code>container_image_tag</code></strong> :&ensp;<code>str</code></dt>
<dd>Container image tag the built image was tagged with.</dd>
<dt><strong><code>container_image_digest</code></strong> :&ensp;<code>str</code></dt>
<dd>Container image digest of built image.</dd>
<dt><strong><code>container_image_build_address</code></strong> :&ensp;<code>str</code></dt>
<dd>Container image full address (with registry) the image was built into and can
be referenced by to push somewhere else.</dd>
<dt><strong><code>container_image_build_short_address</code></strong> :&ensp;<code>str</code></dt>
<dd>Container image short address (without registry) the image was built into and can
be referenced by to push somewhere else, assuming the registry is on the local container
search path.</dd>
</dl>
<h2 id="results">Results</h2>
<p>step_result : StepResult
The given StepResult which was modified in place.
Returned for convenience / and clarity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_container_build_step_result_artifacts(
    step_result,
    contaimer_image_registry,
    container_image_repository,
    container_image_tag,
    container_image_digest,
    container_image_build_address,
    container_image_build_short_address
): # pylint: disable=too-many-arguments
    &#34;&#34;&#34;Helper function to consistently add step results when building a container image.

    NOTE: long term probably should move this into some mixin class that all container build
    StepImplementers also inherit from, but thats another pattern don&#39;t want to introduce right now.

    Parameters
    ----------
    step_result : StepResult
        Step result to add the container build artifacts to.
    contaimer_image_registry : str
        Container image registry the image was built into.
    container_image_repository : str
        Container image repository the image was built into.
    container_image_tag : str
        Container image tag the built image was tagged with.
    container_image_digest : str
        Container image digest of built image.
    container_image_build_address : str
        Container image full address (with registry) the image was built into and can
        be referenced by to push somewhere else.
    container_image_build_short_address : str
        Container image short address (without registry) the image was built into and can
        be referenced by to push somewhere else, assuming the registry is on the local container
        search path.

    Results
    -------
    step_result : StepResult
        The given StepResult which was modified in place.
        Returned for convenience / and clarity.
    &#34;&#34;&#34;
    if contaimer_image_registry:
        step_result.add_artifact(
            name=&#39;container-image-registry&#39;,
            value=contaimer_image_registry,
            description=&#39;Container image registry of the built container image address.&#39;
        )
    if container_image_repository:
        step_result.add_artifact(
            name=&#39;container-image-repository&#39;,
            value=container_image_repository,
            description=&#39;Container image repository of the built container image address.&#39;
        )
    if container_image_tag:
        step_result.add_artifact(
            name=&#39;container-image-tag&#39;,
            value=container_image_tag,
            description=&#39;Container image tag of the built container image address.&#39;
        )
    if container_image_digest:
        step_result.add_artifact(
            name=&#39;container-image-build-digest&#39;,
            value=container_image_digest,
            description=&#39;Container image digest of the built container image address.&#39;
        )
    if container_image_build_address:
        step_result.add_artifact(
            name=&#39;container-image-build-address&#39;,
            value=container_image_build_address,
            description=&#39;Container image address of the built container image.&#39;
        )
    if container_image_build_short_address:
        step_result.add_artifact(
            name=&#39;container-image-build-short-address&#39;,
            value=container_image_build_short_address,
            description=&#39;Container image short address (no registry) of the built container image.&#39;
        )

    return step_result</code></pre>
</details>
</dd>
<dt id="ploigos_step_runner.utils.containers.container_registries_login"><code class="name flex">
<span>def <span class="ident">container_registries_login</span></span>(<span>registries, containers_config_auth_file=None, containers_config_tls_verify=True, container_command_short_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Logs into one or more container registries.</p>
<p>Requires one of the following to be installed to do the authentication:
* buidlah
* podman
* skopeo</p>
<h2 id="notes">Notes</h2>
<p>registries example 1 (dict of dicts where child dict keys are registry uri):</p>
<pre><code>{
    'registry.redhat.io': {
        'username': 'hello@world.xyz',
        'password': 'nope'
    },
    'registry.internal.example.xyz': {
        'username': 'hello@example.xyz',
        'password': 'nope'
    }
}
</code></pre>
<p>registries example 2 (dict of dicts where uri is key in child dicts):</p>
<pre><code>{
    'redhat': {
        'uri': registry.redhat.io
        'username': 'hello@world.xyz',
        'password': 'nope'
    },
    'internal': {
        'uri': 'registry.internal.example.xyz'
        'username': 'hello@example.xyz',
        'password': 'nope'
    }
}
</code></pre>
<p>registries example 3 (list of dicts where uri is key in child dicts):</p>
<pre><code>[
    {
        'uri': registry.redhat.io
        'username': 'hello@world.xyz',
        'password': 'nope'
    },
    {
        'uri': 'registry.internal.example.xyz'
        'username': 'hello@example.xyz',
        'password': 'nope'
    }
]
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>registries</code></strong> :&ensp;<code>dict</code> or <code>list</code> or <code>None</code></dt>
<dd>Dict of dicts of registry configurations or a list of dicts of registry configurations.
See Notes section for details.
If none, does nothing.</dd>
<dt><strong><code>containers_config_auth_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path of the authentication file.
If not specified default of the underlying authentication system will be used.</dd>
<dt><strong><code>container_command_short_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Short name for the command to log in with.
If not provided will pick the first command found in order (buildah, podman, skopeo).</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="ploigos_step_runner.utils.containers.container_registry_login" href="#ploigos_step_runner.utils.containers.container_registry_login">container_registry_login()</a></code></dt>
<dd>Performs the login for a single container registry</dd>
<dt><code>sh.buildah</code></dt>
<dd><a href="https://www.mankier.com/1/buildah-login">https://www.mankier.com/1/buildah-login</a></dd>
<dt><code>sh.podman</code></dt>
<dd><a href="https://www.mankier.com/1/podman-login">https://www.mankier.com/1/podman-login</a></dd>
<dt><code>sh.skopeo</code></dt>
<dd><a href="https://www.mankier.com/1/skopeo-login">https://www.mankier.com/1/skopeo-login</a></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def container_registries_login(  #pylint: disable=too-many-branches
    registries,
    containers_config_auth_file=None,
    containers_config_tls_verify=True,
    container_command_short_name=None
):
    &#34;&#34;&#34;Logs into one or more container registries.

    Requires one of the following to be installed to do the authentication:
    * buidlah
    * podman
    * skopeo

    Notes
    -----
    registries example 1 (dict of dicts where child dict keys are registry uri):

        {
            &#39;registry.redhat.io&#39;: {
                &#39;username&#39;: &#39;hello@world.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            },
            &#39;registry.internal.example.xyz&#39;: {
                &#39;username&#39;: &#39;hello@example.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            }
        }

    registries example 2 (dict of dicts where uri is key in child dicts):

        {
            &#39;redhat&#39;: {
                &#39;uri&#39;: registry.redhat.io
                &#39;username&#39;: &#39;hello@world.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            },
            &#39;internal&#39;: {
                &#39;uri&#39;: &#39;registry.internal.example.xyz&#39;
                &#39;username&#39;: &#39;hello@example.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            }
        }

    registries example 3 (list of dicts where uri is key in child dicts):

        [
            {
                &#39;uri&#39;: registry.redhat.io
                &#39;username&#39;: &#39;hello@world.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            },
            {
                &#39;uri&#39;: &#39;registry.internal.example.xyz&#39;
                &#39;username&#39;: &#39;hello@example.xyz&#39;,
                &#39;password&#39;: &#39;nope&#39;
            }
        ]

    Parameters
    ----------
    registries : dict or list or None
        Dict of dicts of registry configurations or a list of dicts of registry configurations.
        See Notes section for details.
        If none, does nothing.
    containers_config_auth_file : str, optional
        Path of the authentication file.
        If not specified default of the underlying authentication system will be used.
    container_command_short_name : str, optional
        Short name for the command to log in with.
        If not provided will pick the first command found in order (buildah, podman, skopeo).

    See Also
    --------
    container_registry_login : Performs the login for a single container registry
    sh.buildah : https://www.mankier.com/1/buildah-login
    sh.podman : https://www.mankier.com/1/podman-login
    sh.skopeo : https://www.mankier.com/1/skopeo-login
    &#34;&#34;&#34;

    if registries is None:
        return

    assert isinstance(registries, (dict, list))

    if isinstance(registries, dict):
        for registry_key, registry_conf in registries.items():
            if isinstance(registry_conf, ConfigValue):
                registry_conf = registry_conf.value

            assert &#39;username&#39; in registry_conf, \
                f&#34;Configuration for container registry ({registry_key}) &#34; \
                f&#34;must specify a &#39;username&#39;: {registry_conf}&#34;
            assert &#39;password&#39; in registry_conf, \
                f&#34;Configuration for container registry ({registry_key}) &#34; \
                f&#34;must specify a &#39;password&#39;: {registry_conf}&#34;

            # if uri is key in the dict then use that for the registry uri
            # else use the dict key for the registry conf as the registry uri
            if &#39;uri&#39; in registry_conf:
                registry_uri = registry_conf[&#39;uri&#39;]
            else:
                registry_uri = registry_key

            if containers_config_tls_verify:
                if &#39;tls-verify&#39; in registry_conf:
                    registry_tls_verify = registry_conf[&#39;tls-verify&#39;]
                else:
                    registry_tls_verify = True
            else:
                registry_tls_verify = False

            container_registry_login(
                container_registry_uri=registry_uri,
                container_registry_username=registry_conf[&#39;username&#39;],
                container_registry_password=registry_conf[&#39;password&#39;],
                container_registry_tls_verify=registry_tls_verify,
                containers_config_auth_file=containers_config_auth_file,
                container_command_short_name=container_command_short_name
            )
    elif isinstance(registries, list):
        for registry_conf in registries:
            if isinstance(registry_conf, ConfigValue):
                registry_conf = registry_conf.value

            assert &#39;uri&#39; in registry_conf, \
                f&#34;Configuration for container registry &#34; \
                f&#34;must specify a &#39;uri&#39;: {registry_conf}&#34;
            assert &#39;username&#39; in registry_conf, \
                f&#34;Configuration for container registry &#34; \
                f&#34;must specify a &#39;username&#39;: {registry_conf}&#34;
            assert &#39;password&#39; in registry_conf, \
                f&#34;Configuration for container registry &#34; \
                f&#34;must specify a &#39;password&#39;: {registry_conf}&#34;

            if containers_config_tls_verify:
                if &#39;tls-verify&#39; in registry_conf:
                    registry_tls_verify = registry_conf[&#39;tls-verify&#39;]
                else:
                    registry_tls_verify = True
            else:
                registry_tls_verify = False

            container_registry_login(
                container_registry_uri=registry_conf[&#39;uri&#39;],
                container_registry_username=registry_conf[&#39;username&#39;],
                container_registry_password=registry_conf[&#39;password&#39;],
                container_registry_tls_verify=registry_tls_verify,
                containers_config_auth_file=containers_config_auth_file,
                container_command_short_name=container_command_short_name
            )</code></pre>
</details>
</dd>
<dt id="ploigos_step_runner.utils.containers.container_registry_login"><code class="name flex">
<span>def <span class="ident">container_registry_login</span></span>(<span>container_registry_uri, container_registry_username, container_registry_password, container_registry_tls_verify=True, containers_config_auth_file=None, container_command_short_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the login for a single container registry.</p>
<p>Requires one of the following to be installed to do the authentication:
* buidlah
* podman
* skopeo</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>container_registry_uri</code></strong> :&ensp;<code>str</code> or <code>ConfigValue</code></dt>
<dd>URI to the container registry to log into.</dd>
<dt><strong><code>container_registry_username</code></strong> :&ensp;<code>str</code> or <code>ConfigValue</code></dt>
<dd>Username to log into the container registry with.</dd>
<dt><strong><code>container_registry_password</code></strong> :&ensp;<code>str</code> or <code>ConfigValue</code></dt>
<dd>Password to log into the container registry with.</dd>
<dt><strong><code>container_registry_tls_verify</code></strong> :&ensp;<code>bool</code> or <code>str</code> or <code>ConfigValue</code></dt>
<dd>True to verify container registry certificates as part of authenticating.
False to ignore certificate chain.
NOTE: no matter what SSL is used to authenticate with container registry</dd>
<dt><strong><code>containers_config_auth_file</code></strong> :&ensp;<code>str</code> or <code>ConfigValue</code>, optional</dt>
<dd>Path of the authentication file.
If not specified default of the underlying authentication system will be used.</dd>
<dt><strong><code>container_command_short_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Short name for the command to log in with.
If not provided will pick the first command found in order (buildah, podman, skopeo).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>When can not find tool to login to container registry with.
When error loging into container registry.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="ploigos_step_runner.utils.containers.container_registries_login" href="#ploigos_step_runner.utils.containers.container_registries_login">container_registries_login()</a></code></dt>
<dd>authenticate with multiple container registries</dd>
<dt><code>sh.buildah</code></dt>
<dd><a href="https://www.mankier.com/1/buildah-login">https://www.mankier.com/1/buildah-login</a></dd>
<dt><code>sh.podman</code></dt>
<dd><a href="https://www.mankier.com/1/podman-login">https://www.mankier.com/1/podman-login</a></dd>
<dt><code>sh.skopeo</code></dt>
<dd><a href="https://www.mankier.com/1/skopeo-login">https://www.mankier.com/1/skopeo-login</a></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def container_registry_login( #pylint: disable=too-many-arguments,too-many-branches
    container_registry_uri,
    container_registry_username,
    container_registry_password,
    container_registry_tls_verify=True,
    containers_config_auth_file=None,
    container_command_short_name=None
):
    &#34;&#34;&#34;Performs the login for a single container registry.

    Requires one of the following to be installed to do the authentication:
    * buidlah
    * podman
    * skopeo

    Parameters
    ----------
    container_registry_uri : str or ConfigValue
        URI to the container registry to log into.
    container_registry_username : str or ConfigValue
        Username to log into the container registry with.
    container_registry_password : str or ConfigValue
        Password to log into the container registry with.
    container_registry_tls_verify : bool or str or ConfigValue
        True to verify container registry certificates as part of authenticating.
        False to ignore certificate chain.
        NOTE: no matter what SSL is used to authenticate with container registry
    containers_config_auth_file : str or ConfigValue, optional
        Path of the authentication file.
        If not specified default of the underlying authentication system will be used.
    container_command_short_name : str, optional
        Short name for the command to log in with.
        If not provided will pick the first command found in order (buildah, podman, skopeo).

    Raises
    ------
    RuntimeError
        When can not find tool to login to container registry with.
        When error loging into container registry.

    See Also
    --------
    container_registries_login : authenticate with multiple container registries
    sh.buildah : https://www.mankier.com/1/buildah-login
    sh.podman : https://www.mankier.com/1/podman-login
    sh.skopeo : https://www.mankier.com/1/skopeo-login
    &#34;&#34;&#34;

    assert container_registry_uri
    assert container_registry_username
    assert container_registry_password

    if isinstance(container_registry_uri, ConfigValue):
        container_registry_uri = container_registry_uri.value
    if isinstance(container_registry_username, ConfigValue):
        container_registry_username = container_registry_username.value
    if isinstance(container_registry_password, ConfigValue):
        container_registry_password = container_registry_password.value
    if isinstance(container_registry_tls_verify, ConfigValue):
        container_registry_tls_verify = container_registry_tls_verify.value
    if isinstance(containers_config_auth_file, ConfigValue):
        containers_config_auth_file = containers_config_auth_file.value

    # can use any of these tools to authenticate, look for them all and use first available
    #
    # NOTE: this all works because these three commands take the exact same parameters for login
    # if implementing some new command, like docker, you will need to deal with the differences
    buildah_path = sh.which(&#39;buildah&#39;)
    podman_path = sh.which(&#39;podman&#39;)
    skopeo_path = sh.which(&#39;skopeo&#39;)
    if container_command_short_name:
        given_command_path = sh.which(container_command_short_name)
        if given_command_path:
            container_command = sh.Command(container_command_short_name).bake()
        else:
            raise RuntimeError(
                f&#34;When attempting to login to container registry ({container_registry_uri}) &#34;
                f&#34;could not find the given expected tool ({container_command_short_name}) &#34;
                &#34;to login with.&#34;
            )
    elif buildah_path is not None:
        container_command = sh.buildah.bake() #pylint: disable=no-member
    elif podman_path is not None:
        container_command = sh.podman.bake() #pylint: disable=no-member
    elif skopeo_path is not None:
        container_command = sh.skopeo.bake() #pylint: disable=no-member
    else:
        raise RuntimeError(
            f&#34;When attempting to login to container registry ({container_registry_uri}) &#34;
            &#34;could not find one of the expected tools (buildah, podman, skopeo) to login with.&#34;
        )

    login_command_named_flags = {
        &#39;password_stdin&#39;: True,
        &#39;username&#39;: container_registry_username,
        &#39;tls_verify&#39;: str(container_registry_tls_verify).lower()
    }
    if containers_config_auth_file:
        login_command_named_flags[&#39;authfile&#39;] = containers_config_auth_file

    try:
        # NOTE: need to bake in the flags prior to the registry due to nonesense with
        #       required ordering by the login command and how sh handles
        #       escaping and ordering parameters
        print(f&#34;Login ({container_command}) to container image registry ({container_registry_uri})&#34;)
        login_comnmand = container_command.login.bake(**login_command_named_flags)
        login_comnmand(
            container_registry_uri,
            _in=container_registry_password,
            _out=sys.stdout,
            _err=sys.stderr,
            _tee=&#39;err&#39;
        )
    except sh.ErrorReturnCode as error:
        raise RuntimeError(
            f&#34;Failed to login to container registry ({container_registry_uri}) &#34;
            f&#34;with username ({container_registry_username}): {error}&#34;
        ) from error</code></pre>
</details>
</dd>
<dt id="ploigos_step_runner.utils.containers.create_container_from_image"><code class="name flex">
<span>def <span class="ident">create_container_from_image</span></span>(<span>image_address, repository_type='container-storage:')</span>
</code></dt>
<dd>
<div class="desc"><p>Import a container image using buildah form a TAR file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image_address</code></strong> :&ensp;<code>str</code></dt>
<dd>Image tag to create a container from.
ex:
* localhost/my-app:latest
* quay.io/my-org/my-app:latest
* docker-archive:/local/path/to/my-app-container-image.tar</dd>
<dt><strong><code>container_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name for the working container.</dd>
<dt><strong><code>repository_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of repository to mount the given image tag from.
See <a href="https://github.com/containers/skopeo">https://github.com/containers/skopeo</a> for details on different repository types.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Name of the imported container.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If error importing image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_container_from_image(
    image_address,
    repository_type=&#39;container-storage:&#39;
):
    &#34;&#34;&#34;Import a container image using buildah form a TAR file.

    Parameters
    ----------
    image_address : str
        Image tag to create a container from.
        ex:
        * localhost/my-app:latest
        * quay.io/my-org/my-app:latest
        * docker-archive:/local/path/to/my-app-container-image.tar
    container_name : str
        name for the working container.
    repository_type : str
        The type of repository to mount the given image tag from.
        See https://github.com/containers/skopeo for details on different repository types.

    Returns
    -------
    str
        Name of the imported container.

    Raises
    ------
    RuntimeError
        If error importing image.
    &#34;&#34;&#34;
    container_name = None
    try:
        buildah_from_out_buff = StringIO()
        buildah_from_out_callback = create_sh_redirect_to_multiple_streams_fn_callback([
            sys.stdout,
            buildah_from_out_buff
        ])
        sh.buildah(  # pylint: disable=no-member
            &#39;from&#39;,
            f&#34;{repository_type}{image_address}&#34;,
            _out=buildah_from_out_callback,
            _err=sys.stderr,
            _tee=&#39;err&#39;
        )
        container_name = buildah_from_out_buff.getvalue().rstrip()
    except sh.ErrorReturnCode as error:
        raise RuntimeError(
            f&#39;Error creating container from image ({image_address}): {error}&#39;
        ) from error

    return container_name</code></pre>
</details>
</dd>
<dt id="ploigos_step_runner.utils.containers.determine_container_image_address_info"><code class="name flex">
<span>def <span class="ident">determine_container_image_address_info</span></span>(<span>contaimer_image_registry, container_image_tag, organization, application_name, service_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the full and short build tags for a new container image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>container_image_tag</code></strong> :&ensp;<code>str</code></dt>
<dd>A given image version. If none given, latest will be used.</dd>
<dt><strong><code>organization</code></strong> :&ensp;<code>str</code></dt>
<dd>Organization the container image belongs to.</dd>
<dt><strong><code>application_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Application the container image belongs to.</dd>
<dt><strong><code>service_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Service the container image implements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str, str, str, str, str</code></dt>
<dd>First result is the full build tag, including registry URI.
Second result is the short build tag, as in no registry URI.
Third result is the image registry uri.
Forth result is the image repository name.
Fifth result is the used image version.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_container_image_address_info(
    contaimer_image_registry,
    container_image_tag,
    organization,
    application_name,
    service_name
):
    &#34;&#34;&#34;Determines the full and short build tags for a new container image.

    Parameters
    ----------
    container_image_tag : str
        A given image version. If none given, latest will be used.
    organization : str
        Organization the container image belongs to.
    application_name : str
        Application the container image belongs to.
    service_name : str
        Service the container image implements.

    Returns
    -------
    str, str, str, str, str
        First result is the full build tag, including registry URI.
        Second result is the short build tag, as in no registry URI.
        Third result is the image registry uri.
        Forth result is the image repository name.
        Fifth result is the used image version.

    &#34;&#34;&#34;
    if container_image_tag is None:
        container_image_tag = &#39;latest&#39;
        print(&#39;No image tag version found in metadata. Using latest&#39;)

    container_image_repository = f&#34;{organization}/{application_name}&#34;
    if service_name:
        container_image_repository += f&#34;/{service_name}&#34;

    container_image_build_short_address = f&#34;{container_image_repository}:{container_image_tag}&#34;
    container_image_build_address = \
        f&#34;{contaimer_image_registry}/{container_image_build_short_address}&#34;

    return container_image_build_address, container_image_build_short_address,\
        contaimer_image_registry, container_image_repository, container_image_tag</code></pre>
</details>
</dd>
<dt id="ploigos_step_runner.utils.containers.get_container_image_digest"><code class="name flex">
<span>def <span class="ident">get_container_image_digest</span></span>(<span>container_image_address, containers_config_auth_file=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the container image digest for a given container image.</p>
<p>Will pull the given container image if needed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>container_image_address</code></strong> :&ensp;<code>str</code></dt>
<dd>URI to the container image to get the container image digest for.</dd>
<dt><strong><code>containers_config_auth_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to container image registries authentication file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If error inspecting container image to get digest.
If error finding digest on container image inspection results.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Container image digest for given container image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_container_image_digest(
    container_image_address,
    containers_config_auth_file=None
):
    &#34;&#34;&#34;Get the container image digest for a given container image.

    Will pull the given container image if needed.

    Parameters
    ----------
    container_image_address : str
        URI to the container image to get the container image digest for.
    containers_config_auth_file : str
        Path to container image registries authentication file.

    Raises
    ------
    RuntimeError
        If error inspecting container image to get digest.
        If error finding digest on container image inspection results.

    Returns
    -------
    str
        Container image digest for given container image.
    &#34;&#34;&#34;
    try:
        container_image_details = inspect_container_image(
            container_image_address=container_image_address,
            containers_config_auth_file=containers_config_auth_file
        )

        return container_image_details[&#39;FromImageDigest&#39;]
    except RuntimeError as error:
        raise RuntimeError(
            f&#34;Error getting container image ({container_image_address}) image digest: {error}&#34;
        ) from error
    except KeyError as error:
        raise RuntimeError(
            f&#34;Error finding container image ({container_image_address}) image digest from&#34; \
            f&#34; container image inspection.&#34;
        ) from error</code></pre>
</details>
</dd>
<dt id="ploigos_step_runner.utils.containers.inspect_container_image"><code class="name flex">
<span>def <span class="ident">inspect_container_image</span></span>(<span>container_image_address, containers_config_auth_file=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Inspects a given container image for all its details. Useful for getting image labels
and such.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>container_image_address</code></strong> :&ensp;<code>str</code></dt>
<dd>URI to the container image to inspect</dd>
<dt><strong><code>containers_config_auth_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to container image registries authentication file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If issue running <code>buildah inspect</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Container image details from <code>buildah inspect</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inspect_container_image(
    container_image_address,
    containers_config_auth_file=None
):
    &#34;&#34;&#34;Inspects a given container image for all its details. Useful for getting image labels
    and such.

    Parameters
    ----------
    container_image_address : str
        URI to the container image to inspect
    containers_config_auth_file : str
        Path to container image registries authentication file.

    Raises
    ------
    RuntimeError
        If issue running `buildah inspect`

    Returns
    -------
    dict
        Container image details from `buildah inspect`
    &#34;&#34;&#34;
    buildah_inspect = None

    # determine auth flags
    if containers_config_auth_file:
        buildah_authfile_flags = [&#39;--authfile&#39;, containers_config_auth_file]
    else:
        buildah_authfile_flags = []

    # pull container image (can&#39;t inspect remote image)
    try:
        sh.buildah.pull( # pylint: disable=no-member
            *buildah_authfile_flags,
            container_image_address
        )
    except sh.ErrorReturnCode as error:  # pylint: disable=undefined-variable
        raise RuntimeError(
            f&#34;Error pulling container image ({container_image_address}) for inspection: {error}&#34;
        ) from error

    # get container image information
    try:

        buildah_inspect_out_buff = StringIO()
        sh.buildah.inspect( # pylint: disable=no-member
            container_image_address,
            _out=buildah_inspect_out_buff
        )
        buildah_inspect_out = buildah_inspect_out_buff.getvalue().rstrip()
        buildah_inspect = json.loads(buildah_inspect_out)
    except sh.ErrorReturnCode as error:  # pylint: disable=undefined-variable
        raise RuntimeError(
            f&#34;Error inspecting container image ({container_image_address}): {error}&#34;
        ) from error

    return buildah_inspect</code></pre>
</details>
</dd>
<dt id="ploigos_step_runner.utils.containers.mount_container"><code class="name flex">
<span>def <span class="ident">mount_container</span></span>(<span>buildah_unshare_command, container_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Use buildah to mount a container.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>buildah_unshare_command</code></strong> :&ensp;<code>sh.buildah.unshare.bake()</code></dt>
<dd>A baked sh.buildah.unshare command to use to run this command in the context off
so that this can be done "rootless".</dd>
<dt><strong><code>container_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the container to mount.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Absolute path to the mounted container.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If error mounting the container.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mount_container(buildah_unshare_command, container_id):
    &#34;&#34;&#34;Use buildah to mount a container.

    Parameters
    ----------
    buildah_unshare_command : sh.buildah.unshare.bake()
        A baked sh.buildah.unshare command to use to run this command in the context off
        so that this can be done &#34;rootless&#34;.
    container_id : str
        ID of the container to mount.

    Returns
    -------
    str
        Absolute path to the mounted container.

    Raises
    ------
    RuntimeError
        If error mounting the container.
    &#34;&#34;&#34;
    mount_path = None
    try:
        buildah_mount_out_buff = StringIO()
        buildah_mount_out_callback = create_sh_redirect_to_multiple_streams_fn_callback([
            sys.stdout,
            buildah_mount_out_buff
        ])
        buildah_mount_command = buildah_unshare_command.bake(&#34;buildah&#34;, &#34;mount&#34;)
        buildah_mount_command(
            container_id,
            _out=buildah_mount_out_callback,
            _err=sys.stderr,
            _tee=&#39;err&#39;
        )
        mount_path = buildah_mount_out_buff.getvalue().rstrip()
    except sh.ErrorReturnCode as error:
        raise RuntimeError(
            f&#39;Error mounting container ({container_id}): {error}&#39;
        ) from error

    return mount_path</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ploigos_step_runner.utils" href="index.html">ploigos_step_runner.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ploigos_step_runner.utils.containers.add_container_build_step_result_artifacts" href="#ploigos_step_runner.utils.containers.add_container_build_step_result_artifacts">add_container_build_step_result_artifacts</a></code></li>
<li><code><a title="ploigos_step_runner.utils.containers.container_registries_login" href="#ploigos_step_runner.utils.containers.container_registries_login">container_registries_login</a></code></li>
<li><code><a title="ploigos_step_runner.utils.containers.container_registry_login" href="#ploigos_step_runner.utils.containers.container_registry_login">container_registry_login</a></code></li>
<li><code><a title="ploigos_step_runner.utils.containers.create_container_from_image" href="#ploigos_step_runner.utils.containers.create_container_from_image">create_container_from_image</a></code></li>
<li><code><a title="ploigos_step_runner.utils.containers.determine_container_image_address_info" href="#ploigos_step_runner.utils.containers.determine_container_image_address_info">determine_container_image_address_info</a></code></li>
<li><code><a title="ploigos_step_runner.utils.containers.get_container_image_digest" href="#ploigos_step_runner.utils.containers.get_container_image_digest">get_container_image_digest</a></code></li>
<li><code><a title="ploigos_step_runner.utils.containers.inspect_container_image" href="#ploigos_step_runner.utils.containers.inspect_container_image">inspect_container_image</a></code></li>
<li><code><a title="ploigos_step_runner.utils.containers.mount_container" href="#ploigos_step_runner.utils.containers.mount_container">mount_container</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>